import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers':
    'authorization, x-client-info, apikey, content-type',
}

interface UserRecord {
  id: string
  email: string
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
interface WebhookPayload {
  type: 'INSERT'
  record: UserRecord
}

Deno.serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const body = await req.json()

    const userRecord: UserRecord = body.type === 'INSERT' ? body.record : body

    if (!userRecord || !userRecord.id || !userRecord.email) {
      throw new Error('Invalid user data received.')
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const serviceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const supabaseAdmin = createClient(supabaseUrl, serviceRoleKey)

    const uuid = crypto.randomUUID().replace(/-/g, '')
    const schemaName = `tenant_${uuid}`
    const displayName = `Tenant ${uuid.slice(0, 8)}`

    console.log(
      `[1/3] Provisioning new tenant for ${userRecord.email}: ${schemaName}`
    )

    const sanitizedDisplayName = displayName.replace(/'/g, "''")
    const sanitizedEmail = userRecord.email.replace(/'/g, "''")

    const provisionSql = `
      -- Create tenant schema and grant access
      CREATE SCHEMA "${schemaName}";
      GRANT USAGE ON SCHEMA "${schemaName}" TO authenticated;
      GRANT CREATE ON SCHEMA "${schemaName}" TO authenticated;
      
      -- Tables
      CREATE TABLE "${schemaName}".notes ( id bigint generated by default as identity primary key, user_id uuid references auth.users(id) on delete cascade, title text not null, content text, tags text[], is_favorite boolean default false, created_at timestamptz default now() not null, updated_at timestamptz default now() not null );
      CREATE TABLE "${schemaName}".categories ( id bigint generated by default as identity primary key, name text not null unique, color text default '#3b82f6', created_at timestamptz default now() not null );
      CREATE TABLE "${schemaName}".note_categories ( note_id bigint references "${schemaName}".notes(id) on delete cascade, category_id bigint references "${schemaName}".categories(id) on delete cascade, primary key (note_id, category_id) );
      CREATE TABLE "${schemaName}".tenant_settings ( id bigint generated by default as identity primary key, setting_key text not null unique, setting_value jsonb, created_at timestamptz default now() not null, updated_at timestamptz default now() not null );
      CREATE TABLE "${schemaName}".user_profiles ( id uuid primary key references auth.users(id) on delete cascade, display_name text, avatar_url text, role text default 'user' check (role in ('admin', 'user', 'viewer')), is_active boolean default true, last_login timestamptz, created_at timestamptz default now() not null, updated_at timestamptz default now() not null );
      
      -- Permissions
      GRANT ALL ON ALL TABLES IN SCHEMA "${schemaName}" TO authenticated;
      
      -- RLS
      ALTER TABLE "${schemaName}".notes ENABLE ROW LEVEL SECURITY;
      CREATE POLICY "Enable read access to notes based on user_id" ON "${schemaName}".notes AS PERMISSIVE FOR ALL TO authenticated USING (user_id = auth.uid());
      GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA "${schemaName}" TO authenticated;

      -- Trigger function
      CREATE OR REPLACE FUNCTION update_updated_at_column() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = now(); RETURN NEW; END; $$ language 'plpgsql';
      
      -- Triggers
      CREATE TRIGGER update_notes_updated_at BEFORE UPDATE ON "${schemaName}".notes FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
      CREATE TRIGGER update_tenant_settings_updated_at BEFORE UPDATE ON "${schemaName}".tenant_settings FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
      CREATE TRIGGER update_user_profiles_updated_at BEFORE UPDATE ON "${schemaName}".user_profiles FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

      -- Insert default categories
      INSERT INTO "${schemaName}".categories (name, color) VALUES 
        ('Personal', '#3b82f6'), ('Work', '#10b981'), ('Ideas', '#f59e0b'), ('Important', '#ef4444');

      -- Insert initial tenant settings with corrected JSON string formatting
      INSERT INTO "${schemaName}".tenant_settings (setting_key, setting_value) VALUES 
        ('tenant_name', '"${sanitizedDisplayName}"'),
        ('created_by', '"${sanitizedEmail}"'),
        ('theme', '{"value": "default"}'),
        ('features', '{"notes": true, "categories": true, "sharing": false}'),
        ('limits', '{"max_notes": 1000, "max_users": 10}');
    `

    const { error: rpcError } = await supabaseAdmin.rpc('execute_sql', {
      sql_query: provisionSql,
    })

    if (rpcError) {
      throw new Error(`[1/3] Schema creation failed: ${rpcError.message}`)
    }
    console.log(`[1/3] ✅ Schema, tables, and data created successfully.`)

    // --- STEP 2: Update user metadata ---
    console.log(`[2/3] Updating user metadata...`)
    const { error: updateUserError } =
      await supabaseAdmin.auth.admin.updateUserById(userRecord.id, {
        user_metadata: { schemaName: schemaName },
      })

    if (updateUserError)
      throw new Error(
        `[2/3] Metadata update failed: ${updateUserError.message}`
      )
    console.log(`[2/3] ✅ Metadata updated for ${userRecord.email}`)

    // --- STEP 3: Return success response ---
    console.log(`[3/3] ✅ Tenant provisioning complete for ${userRecord.email}`)
    return new Response(
      JSON.stringify({ success: true, schemaName: schemaName }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    )
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : 'Unknown error'
    console.error('❌ Tenant provisioning failed:', message, error)
    return new Response(JSON.stringify({ success: false, error: message }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500,
    })
  }
})
